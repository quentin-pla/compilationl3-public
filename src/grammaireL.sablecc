Package sc;

Helpers

lettre = [['a' .. 'z'] + ['A' .. 'Z']];
espaces = (' ' | 13 | 10)*;
commentaire = '#' [[0 .. 0xffff] - [10 + 13]]* (10 | 13 | 10 13);

Tokens

number = ['0' .. '9']+;
plus = '+';
moins = '-';
mult = '*';
div = '/';
egal = '=';
mod = '%';
ou = '|';
et = '&';
inf = '<';
sup = '>';
non = '!';
l_par = '(';
r_par = ')';
l_cro = '[';
r_cro = ']';
l_bra = '{';
r_bra = '}';
virgule = ',';
ptvirgule = ';';
entier = 'entier';
si = 'si';
alors = 'alors';
sinon = 'sinon';
tantque = 'tantque';
faire = 'faire';
retour = 'retour';
id = lettre+;
ignore = (espaces | commentaire)*;

Ignored Tokens

ignore;

Productions

prog = {programme} ldvo ldf;
ldvo = {vars} ldv ptvirgule | {vide};
    ldv = {vars} dv ldvb | {vide};
        dv = {var} entier id | {tabvar} entier id l_cro number r_cro;
        ldvb = {vars} virgule dv ldvb | {vide};

ldf = {functions} df ldf | {vide};
    df = {function} id l_par ldv r_par ibloc;

    i = {affectation} iaff | {si} isi | {tantque} itq | {appel} iapp | {retour} iret | {bloc} ibloc | {vide};
        iaff = {entier} var egal e ptvirgule i;
        isi = {bloc} si e alors ibloc isinon;
            isinon = {bloc} sinon ibloc i | {vide} i;
        itq = {bloc} tantque e faire ibloc i;
        iapp = {appel} app ptvirgule i;
            app = {fonction} id l_par e r_par;
        iret = {exp} retour e ptvirgule i;
        ibloc = {i} l_bra i r_bra;

    var = {identifiant} id | {identifiant2} id l_cro e r_cro;

    e = {ou} e ou e1 | {e1} e1;
        e1 = {et} e1 et e2 | {e2} e2;
        e2 = {egal} e2 egal e3 | {inf} e2 inf e3 | {e3} e3;
        e3 = {plus} e3 plus e4 | {moins} e3 moins e4 | {e4} e4;
        e4 = {mult} e4 mult e5 | {div} e4 div e5 | {e5} e5;
        e5 = {non} non e5 | {e6} e6;
        e6 = {virgule} e6 virgule e7 | {e7} e7;
        e7 = {expression} l_par e r_par | {number} number | {appel} app | {variable} var | {vide};